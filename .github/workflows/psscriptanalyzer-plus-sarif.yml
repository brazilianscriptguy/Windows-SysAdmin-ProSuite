name: PowerShell Corporate Lint (PSScriptAnalyzer + SARIF + Reports)

on:
  push:
    branches: [main, develop]
    paths:
      - "**/*.ps1"
      - "**/*.psm1"
      - "**/*.psd1"
      - ".psscriptanalyzer.psd1"
  pull_request:
    branches: [main, develop]
    paths:
      - "**/*.ps1"
      - "**/*.psm1"
      - "**/*.psd1"
      - ".psscriptanalyzer.psd1"
  workflow_dispatch:

concurrency:
  group: powershell-lint-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  psa-analyze:
    name: üß™ Analyze (PSScriptAnalyzer 1.24.0) + Reports
    runs-on: ubuntu-latest
    timeout-minutes: 25

    permissions:
      contents: read
      security-events: write

    env:
      PSA_VERSION: "1.24.0"
      SETTINGS_FILE: ".psscriptanalyzer.psd1"

      OUT_DIR: "lint-reports"
      OUT_JSON: "psa-results.json"
      OUT_CSV: "psa-results.csv"
      OUT_MD: "psa-results.md"
      OUT_SARIF: "psa-results.sarif"

      # Prune folders from scanning
      PRUNE_DIR_REGEX: '[\\/](\.git|node_modules|dist|build|artifacts|\.next)[\\/]'

      # Your repo ‚Äúmain roots‚Äù (scanned recursively)
      ANALYZE_ROOTS: >-
        BlueTeam-Tools
        Core-ScriptLibrary
        ITSM-Templates-SVR
        ITSM-Templates-WKS
        ProSuite-Hub
        SysAdmin-Tools

      # Fail gate: job fails if ANY of these severities exist
      FAIL_ON_SEVERITIES: "Error"

      # Optional: cap the amount of findings shown in summary/report
      SUMMARY_TOP: "25"

    steps:
      - name: üì¶ Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîé Discover PowerShell files
        id: discover
        shell: bash
        run: |
          set -euo pipefail
          cd "$GITHUB_WORKSPACE"

          count="$(find . \
            -type d \( -name .git -o -name node_modules -o -name dist -o -name build -o -name artifacts -o -name .next \) -prune -false \
            -o -type f \( -name "*.ps1" -o -name "*.psm1" -o -name "*.psd1" \) -print | wc -l | tr -d ' ')"

          echo "count=$count" >> "$GITHUB_OUTPUT"
          echo "Found $count PowerShell file(s)."

      - name: üß± Cache PowerShell modules
        if: steps.discover.outputs.count != '0'
        uses: actions/cache@v4
        with:
          path: |
            ~/.local/share/powershell/Modules
            ~/.config/powershell/Modules
          key: psmodules-${{ runner.os }}-psa-${{ env.PSA_VERSION }}

      - name: üß© Install / Import PSScriptAnalyzer
        if: steps.discover.outputs.count != '0'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $required = [version]'${{ env.PSA_VERSION }}'

          $installed = Get-Module -ListAvailable -Name PSScriptAnalyzer |
            Sort-Object Version -Descending | Select-Object -First 1

          if (-not $installed -or $installed.Version -ne $required) {
            Set-PSRepository -Name PSGallery -InstallationPolicy Trusted | Out-Null
            Install-Module -Name PSScriptAnalyzer -RequiredVersion $required -Scope CurrentUser -Force
          }

          Import-Module PSScriptAnalyzer -Force
          Write-Host "PSScriptAnalyzer version: $((Get-Module PSScriptAnalyzer).Version)"

      - name: ‚úÖ Validate settings file
        if: steps.discover.outputs.count != '0'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $settingsPath = Join-Path $env:GITHUB_WORKSPACE '${{ env.SETTINGS_FILE }}'
          if (-not (Test-Path $settingsPath)) { throw "Missing settings file: $settingsPath" }

          $cfg = Import-PowerShellDataFile -Path $settingsPath
          if (-not ($cfg -is [hashtable])) { throw "Settings file is not a hashtable: $settingsPath" }

          $validKeys = @('CustomRulePath','ExcludeRules','IncludeRules','IncludeDefaultRules','RecurseCustomRulePath','Rules','Severity')
          foreach ($k in $cfg.Keys) {
            if ($k -notin $validKeys) {
              throw "Invalid key in .psscriptanalyzer.psd1: '$k'. Valid keys: $($validKeys -join ', ')"
            }
          }

          Write-Host "Settings file OK: $settingsPath"

      - name: üïí Capture run metadata
        if: steps.discover.outputs.count != '0'
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          echo "timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> "$GITHUB_OUTPUT"
          echo "sha=${GITHUB_SHA}" >> "$GITHUB_OUTPUT"
          echo "ref=${GITHUB_REF}" >> "$GITHUB_OUTPUT"
          echo "repo=${GITHUB_REPOSITORY}" >> "$GITHUB_OUTPUT"

      - name: üóÇÔ∏è Ensure report folder exists
        if: steps.discover.outputs.count != '0'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $outDir = Join-Path $env:GITHUB_WORKSPACE '${{ env.OUT_DIR }}'
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null
          Write-Host "Report folder ready: $outDir"

      # OPTION A: Always create a baseline SARIF so Code Scanning never breaks due to missing file
      - name: ‚úÖ Create baseline SARIF (always)
        if: steps.discover.outputs.count != '0'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $root   = $env:GITHUB_WORKSPACE
          $outDir = Join-Path $root '${{ env.OUT_DIR }}'
          $sarif  = Join-Path $outDir '${{ env.OUT_SARIF }}'
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          $baseline = @{
            '$schema' = 'http://json.schemastore.org/sarif-2.1.0'
            version   = '2.1.0'
            runs      = @(
              @{
                tool    = @{ driver = @{ name = 'PSScriptAnalyzer'; version = '${{ env.PSA_VERSION }}' } }
                results = @()
              }
            )
          }
          $baseline | ConvertTo-Json -Depth 10 | Set-Content -Path $sarif -Encoding UTF8
          Write-Host "Baseline SARIF created: $sarif"

      - name: üîé Run PSScriptAnalyzer + Build Reports (JSON/CSV/MD/SARIF)
        if: steps.discover.outputs.count != '0'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $root       = $env:GITHUB_WORKSPACE
          $settings   = Join-Path $root '${{ env.SETTINGS_FILE }}'
          $outDir     = Join-Path $root '${{ env.OUT_DIR }}'
          $jsonPath   = Join-Path $outDir '${{ env.OUT_JSON }}'
          $csvPath    = Join-Path $outDir '${{ env.OUT_CSV }}'
          $mdPath     = Join-Path $outDir '${{ env.OUT_MD }}'
          $sarifPath  = Join-Path $outDir '${{ env.OUT_SARIF }}'

          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          $prune = [regex]::new('${{ env.PRUNE_DIR_REGEX }}')

          $roots = @("${{ env.ANALYZE_ROOTS }}".Split(" ", [System.StringSplitOptions]::RemoveEmptyEntries)) |
            ForEach-Object { Join-Path $root $_ } |
            Where-Object { Test-Path $_ -and -not $prune.IsMatch($_) }

          if (-not $roots -or $roots.Count -eq 0) {
            throw "No valid ANALYZE_ROOTS found. Check env.ANALYZE_ROOTS."
          }

          $results = @()
          foreach ($r in $roots) {
            $rRel = $r.Replace("$root$([IO.Path]::DirectorySeparatorChar)", '')
            Write-Host "Analyzing root: $rRel"
            $res = Invoke-ScriptAnalyzer -Path $r -Recurse -Settings $settings -Severity @('Error','Warning','Information')
            if ($res) { $results += $res }
          }

          # Normalize into structured rows
          $rows = @()
          foreach ($x in $results) {
            $rel = $x.ScriptPath.Replace("$root$([IO.Path]::DirectorySeparatorChar)", '').Replace('\','/')
            $rows += [pscustomobject]@{
              Severity   = [string]$x.Severity
              RuleName   = [string]$x.RuleName
              Message    = [string]$x.Message
              File       = $rel
              Line       = [int]$x.Line
              Column     = [int]$x.Column
              EndLine    = [int]$x.EndLine
              EndColumn  = [int]$x.EndColumn
              ScriptName = [string]$x.ScriptName
            }
          }

          # JSON
          $rows | ConvertTo-Json -Depth 8 | Set-Content -Path $jsonPath -Encoding UTF8

          # CSV
          $rows | Export-Csv -Path $csvPath -NoTypeInformation -Encoding UTF8

          # SARIF (overwrite baseline with actual results)
          $psaVersion = (Get-Module -ListAvailable PSScriptAnalyzer | Sort-Object Version -Descending | Select-Object -First 1).Version.ToString()
          $sarifResults = @()

          foreach ($r in $rows) {
            $sarifLevel = switch ($r.Severity.ToLowerInvariant()) {
              'error'   { 'error' }
              'warning' { 'warning' }
              default   { 'note' }
            }

            $sarifResults += @{
              ruleId    = $r.RuleName
              level     = $sarifLevel
              message   = @{ text = $r.Message }
              locations = @(
                @{
                  physicalLocation = @{
                    artifactLocation = @{ uri = $r.File }
                    region           = @{
                      startLine   = $r.Line
                      startColumn = $r.Column
                    }
                  }
                }
              )
            }
          }

          $sarif = @{
            '$schema' = 'http://json.schemastore.org/sarif-2.1.0'
            version   = '2.1.0'
            runs      = @(
              @{
                tool    = @{ driver = @{ name = 'PSScriptAnalyzer'; version = $psaVersion } }
                results = $sarifResults
              }
            )
          }
          $sarif | ConvertTo-Json -Depth 12 | Set-Content -Path $sarifPath -Encoding UTF8

          # Markdown report
          $total  = $rows.Count
          $bySev  = $rows | Group-Object Severity | Sort-Object Name
          $byRule = $rows | Group-Object RuleName | Sort-Object Count -Descending

          $repo = '${{ steps.meta.outputs.repo }}'
          $sha  = '${{ steps.meta.outputs.sha }}'
          $ts   = '${{ steps.meta.outputs.timestamp }}'
          $topN = [int]'${{ env.SUMMARY_TOP }}'

          $md = New-Object System.Collections.Generic.List[string]
          $md.Add("# PowerShell Static Analysis Report")
          $md.Add("")
          $md.Add("- **Repo:** $repo")
          $md.Add("- **Commit:** $sha")
          $md.Add("- **Timestamp (UTC):** $ts")
          $md.Add("- **Analyzer:** PSScriptAnalyzer $psaVersion")
          $md.Add("")

          $md.Add("## Summary")
          $md.Add("- **Total findings:** $total")
          foreach ($g in $bySev) { $md.Add("- **$($g.Name):** $($g.Count)") }
          $md.Add("")

          $md.Add("## Top Rules (by count)")
          $md.Add("")
          $md.Add("| Rule | Count |")
          $md.Add("|---|---:|")
          foreach ($r in ($byRule | Select-Object -First 20)) {
            $md.Add("| `$($r.Name)` | $($r.Count) |")
          }
          $md.Add("")

          $md.Add("## First $topN Findings")
          $md.Add("")
          $md.Add("| Severity | Rule | File | Line | Message |")
          $md.Add("|---|---|---|---:|---|")

          foreach ($i in ($rows | Select-Object -First $topN)) {
            $fileLink = "https://github.com/$repo/blob/$sha/$($i.File)#L$($i.Line)"
            $msg = ($i.Message -replace '\|','/')
            $md.Add("| $($i.Severity) | `$($i.RuleName)` | [$($i.File)]($fileLink) | $($i.Line) | $msg |")
          }

          $mdText = ($md -join "`n")
          $mdText | Set-Content -Path $mdPath -Encoding UTF8

          # Job summary (short) - SAFE join
          $summary = New-Object System.Collections.Generic.List[string]
          $summary.Add("### üß™ PowerShell Lint Summary")
          $summary.Add("- üïí **UTC:** $ts")
          $summary.Add("- üîó **Repo:** $repo")
          $summary.Add("- üß∑ **Commit:** $sha")
          $summary.Add("- üßæ **Total findings:** $total")
          foreach ($g in $bySev) { $summary.Add("  - **$($g.Name):** $($g.Count)") }
          $summary.Add("")
          $summary.Add("Artifacts: JSON / CSV / MD / SARIF are in `${{ env.OUT_DIR }}`")

          $summaryText = ($summary -join "`n")
          $summaryText | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8

          # Gate: fail if any configured severities exist
          $failSev = @("${{ env.FAIL_ON_SEVERITIES }}".Split(" ", [System.StringSplitOptions]::RemoveEmptyEntries))
          if ($failSev.Count -gt 0) {
            $failHits = $rows | Where-Object { $_.Severity -in $failSev }
            if ($failHits.Count -gt 0) {
              throw "Lint gate failed: found $($failHits.Count) finding(s) with severity: $($failSev -join ', ')"
            }
          }

      - name: üì¶ Upload Report Artifacts (Structured)
        if: always() && hashFiles(format('{0}/{1}/*', github.workspace, env.OUT_DIR)) != ''
        uses: actions/upload-artifact@v4
        with:
          name: powershell-lint-reports
          path: ${{ github.workspace }}/${{ env.OUT_DIR }}
          retention-days: 30

      # OPTION B: Only upload SARIF if it exists
      - name: üõ∞Ô∏è Upload SARIF to GitHub Code Scanning
        if: always() && hashFiles(format('{0}/{1}/{2}', github.workspace, env.OUT_DIR, env.OUT_SARIF)) != ''
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: ${{ github.workspace }}/${{ env.OUT_DIR }}/${{ env.OUT_SARIF }}
          wait-for-processing: true

  ps51-parse-check:
    name: üß© PowerShell 5.1 Parse Compatibility (Windows)
    runs-on: windows-latest
    timeout-minutes: 15
    needs: psa-analyze

    permissions:
      contents: read

    steps:
      - name: üì¶ Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ‚úÖ Parse all PowerShell files with Windows PowerShell 5.1
        shell: powershell
        run: |
          $ErrorActionPreference = "Stop"

          $prune = '\\(\.git|node_modules|dist|build|artifacts|\.next)\\'

          $files = Get-ChildItem -Recurse -File -Include *.ps1,*.psm1,*.psd1 |
            Where-Object { $_.FullName -notmatch $prune }

          if (-not $files -or $files.Count -eq 0) {
            Write-Host "No PowerShell files found. Skipping."
            exit 0
          }

          $fail = 0
          foreach ($f in $files) {
            $tokens = $null
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($f.FullName, [ref]$tokens, [ref]$errors) | Out-Null
            if ($errors -and $errors.Count -gt 0) {
              $fail++
              Write-Host "==== PARSE ERROR: $($f.FullName) ===="
              $errors | ForEach-Object { Write-Host $_.Message }
            }
          }

          if ($fail -gt 0) {
            throw "PowerShell 5.1 parse failed for $fail file(s)."
          }

          Write-Host "PowerShell 5.1 parse check: OK"
