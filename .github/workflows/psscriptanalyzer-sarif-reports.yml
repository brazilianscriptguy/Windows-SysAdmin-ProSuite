name: PowerShell Corporate Lint (PSScriptAnalyzer + SARIF + Reports)

on:
  push:
    branches: [main, develop]
    paths:
      - "**/*.ps1"
      - "**/*.psm1"
      - "**/*.psd1"
      - ".psscriptanalyzer.psd1"
      - ".github/workflows/psscriptanalyzer-sarif-reports.yml"
  pull_request:
    branches: [main, develop]
    paths:
      - "**/*.ps1"
      - "**/*.psm1"
      - "**/*.psd1"
      - ".psscriptanalyzer.psd1"
      - ".github/workflows/psscriptanalyzer-sarif-reports.yml"
  workflow_dispatch:

concurrency:
  group: powershell-lint-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  psa-analyze:
    name: üß™ Analyze (PSScriptAnalyzer 1.24.0) + Reports
    runs-on: windows-latest
    timeout-minutes: 35

    permissions:
      contents: read
      security-events: write

    env:
      PSA_VERSION: "1.24.0"
      SETTINGS_FILE: ".psscriptanalyzer.psd1"

      OUT_DIR: "lint-reports"
      OUT_JSON: "psa-results.json"
      OUT_CSV: "psa-results.csv"
      OUT_MD: "psa-results.md"
      OUT_SARIF: "psa-results.sarif"

      # Roots to scan (recursive)
      ANALYZE_ROOTS: >-
        BlueTeam-Tools
        Core-ScriptLibrary
        ITSM-Templates-SVR
        ITSM-Templates-WKS
        ProSuite-Hub
        SysAdmin-Tools

      # EXCLUDED subtree (long paths / GPO export content)
      EXCLUDE_SUBTREE: "SysAdmin-Tools/GroupPolicyObjects-Templates"

      # Directory prune (general)
      PRUNE_DIR_REGEX: '(?i)[\\/](\.git|node_modules|dist|build|artifacts|\.next)[\\/]'

      # Optional: suppress some rules only for GUI-like scripts
      GUI_PATH_REGEX: '(?i)(GUI|WinForms|Form|Launcher)\.(ps1|psm1)$'
      GUI_SUPPRESS_RULES: "PSAvoidUsingWriteHost PSAvoidUsingCmdletAliases"

      # Gate policy
      FAIL_ON_SEVERITIES: "Error"

      # Summary limits
      SUMMARY_TOP: "25"
      TOP_RULES: "20"

      # SARIF category (GitHub-supported way to keep runs distinct)
      SARIF_CATEGORY: "powershell/psscriptanalyzer"

    steps:
      - name: üì¶ Checkout (sparse, exclude long-path subtree)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          sparse-checkout-cone-mode: false
          sparse-checkout: |
            BlueTeam-Tools
            Core-ScriptLibrary
            ITSM-Templates-SVR
            ITSM-Templates-WKS
            ProSuite-Hub
            SysAdmin-Tools
            .psscriptanalyzer.psd1
            !SysAdmin-Tools/GroupPolicyObjects-Templates

      - name: üîß Git long paths (safety)
        shell: pwsh
        run: |
          git config --global core.longpaths true

      - name: üîé Discover PowerShell files (respect excludes)
        id: discover
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $root = $env:GITHUB_WORKSPACE
          $prune = [regex]::new($env:PRUNE_DIR_REGEX)
          $excludeSub = ($env:EXCLUDE_SUBTREE -replace '/', [IO.Path]::DirectorySeparatorChar)

          $roots = @()
          foreach ($token in ($env:ANALYZE_ROOTS -split '\s+')) {
            if ([string]::IsNullOrWhiteSpace($token)) { continue }
            $p = Join-Path $root $token
            if (Test-Path $p) { $roots += $p }
          }

          if (-not $roots -or $roots.Count -eq 0) {
            "count=0" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            Write-Host "No ANALYZE_ROOTS found in checkout."
            exit 0
          }

          $files = foreach ($r in $roots) {
            Get-ChildItem -Path $r -Recurse -File -Include *.ps1,*.psm1,*.psd1 -ErrorAction SilentlyContinue |
              Where-Object {
                ($_.FullName -notmatch $prune) -and
                ($_.FullName -notmatch [regex]::Escape($excludeSub))
              }
          }

          $files = @($files | Sort-Object FullName -Unique)
          $count = @($files).Count

          "count=$count" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          Write-Host "Found $count PowerShell file(s) to analyze (after excludes)."

      - name: üß± Cache PowerShell modules
        if: steps.discover.outputs.count != '0'
        uses: actions/cache@v4
        with:
          path: |
            ~\Documents\PowerShell\Modules
            ~\AppData\Local\PowerShell\Modules
          key: psmodules-${{ runner.os }}-psa-${{ env.PSA_VERSION }}

      - name: üß© Install / Import PSScriptAnalyzer
        if: steps.discover.outputs.count != '0'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $required = [version]$env:PSA_VERSION

          $installed = Get-Module -ListAvailable -Name PSScriptAnalyzer |
            Sort-Object Version -Descending | Select-Object -First 1

          if (-not $installed -or $installed.Version -ne $required) {
            Set-PSRepository -Name PSGallery -InstallationPolicy Trusted | Out-Null
            Install-Module -Name PSScriptAnalyzer -RequiredVersion $required -Scope CurrentUser -Force
          }

          Import-Module PSScriptAnalyzer -Force
          Write-Host "PSScriptAnalyzer version: $((Get-Module PSScriptAnalyzer).Version)"

      - name: ‚úÖ Validate settings file
        if: steps.discover.outputs.count != '0'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $settingsPath = Join-Path $env:GITHUB_WORKSPACE $env:SETTINGS_FILE
          if (-not (Test-Path $settingsPath)) { throw "Missing settings file: $settingsPath" }

          $cfg = Import-PowerShellDataFile -Path $settingsPath
          if (-not ($cfg -is [hashtable])) { throw "Settings file is not a hashtable: $settingsPath" }

          $validKeys = @('CustomRulePath','ExcludeRules','IncludeRules','IncludeDefaultRules','RecurseCustomRulePath','Rules','Severity')
          foreach ($k in $cfg.Keys) {
            if ($k -notin $validKeys) {
              throw "Invalid key in .psscriptanalyzer.psd1: '$k'. Valid keys: $($validKeys -join ', ')"
            }
          }

          Write-Host "Settings file OK: $settingsPath"

      - name: üïí Capture run metadata
        if: steps.discover.outputs.count != '0'
        id: meta
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          "timestamp=$([DateTime]::UtcNow.ToString('yyyy-MM-ddTHH:mm:ssZ'))" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "sha=${{ github.sha }}" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "repo=${{ github.repository }}" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "runid=${{ github.run_id }}" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: ‚úÖ Ensure report folder + baseline SARIF exist
        if: steps.discover.outputs.count != '0'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $root   = $env:GITHUB_WORKSPACE
          $outDir = Join-Path $root $env:OUT_DIR
          $sarif  = Join-Path $outDir $env:OUT_SARIF

          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          $baseline = @{
            '$schema' = 'http://json.schemastore.org/sarif-2.1.0'
            version   = '2.1.0'
            runs      = @(
              @{
                tool    = @{ driver = @{ name = 'PSScriptAnalyzer'; version = '0' } }
                results = @()
              }
            )
          }

          $baseline | ConvertTo-Json -Depth 12 | Set-Content -Path $sarif -Encoding UTF8
          if (-not (Test-Path $sarif)) { throw "Failed to create baseline SARIF: $sarif" }

      - name: üîé Run PSScriptAnalyzer + Build Reports (JSON/CSV/MD/SARIF)
        if: steps.discover.outputs.count != '0'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $root      = $env:GITHUB_WORKSPACE
          $settings  = Join-Path $root $env:SETTINGS_FILE

          $outDir    = Join-Path $root $env:OUT_DIR
          $jsonPath  = Join-Path $outDir $env:OUT_JSON
          $csvPath   = Join-Path $outDir $env:OUT_CSV
          $mdPath    = Join-Path $outDir $env:OUT_MD
          $sarifPath = Join-Path $outDir $env:OUT_SARIF

          $prune = [regex]::new($env:PRUNE_DIR_REGEX)
          $excludeSub = ($env:EXCLUDE_SUBTREE -replace '/', [IO.Path]::DirectorySeparatorChar)

          $repo = "${{ steps.meta.outputs.repo }}"
          $sha  = "${{ steps.meta.outputs.sha }}"
          $ts   = "${{ steps.meta.outputs.timestamp }}"
          $runId = "${{ steps.meta.outputs.runid }}"

          $psaVersion = (Get-Module -ListAvailable PSScriptAnalyzer | Sort-Object Version -Descending | Select-Object -First 1).Version.ToString()

          # Collect files to analyze (file-by-file avoids -Path string[] issue)
          $roots = @()
          foreach ($token in ($env:ANALYZE_ROOTS -split '\s+')) {
            if ([string]::IsNullOrWhiteSpace($token)) { continue }
            $p = Join-Path $root $token
            if (Test-Path $p) { $roots += $p }
          }

          $files = foreach ($r in $roots) {
            Get-ChildItem -Path $r -Recurse -File -Include *.ps1,*.psm1,*.psd1 -ErrorAction SilentlyContinue |
              Where-Object {
                ($_.FullName -notmatch $prune) -and
                ($_.FullName -notmatch [regex]::Escape($excludeSub))
              }
          }
          $files = @($files | Sort-Object FullName -Unique)

          $all = New-Object System.Collections.Generic.List[object]
          foreach ($f in $files) {
            try {
              $res = Invoke-ScriptAnalyzer -Path $f.FullName -Settings $settings -Severity @('Error','Warning','Information')
              if ($res) { foreach ($x in $res) { $all.Add($x) } }
            } catch {
              # Don't stop the entire run for a single file; record a synthetic finding.
              $all.Add([pscustomobject]@{
                Severity   = 'Error'
                RuleName   = 'PSScriptAnalyzerInvocationFailed'
                Message    = $_.Exception.Message
                ScriptPath = $f.FullName
                Line       = 1
                Column     = 1
                EndLine    = 1
                EndColumn  = 1
                ScriptName = $f.Name
              })
            }
          }

          # Normalize to rows
          $rows = New-Object System.Collections.Generic.List[object]
          foreach ($x in $all) {
            $rel = $x.ScriptPath.Replace($root + [IO.Path]::DirectorySeparatorChar, '').Replace('\','/')
            $rows.Add([pscustomobject]@{
              Severity   = [string]$x.Severity
              RuleName   = [string]$x.RuleName
              Message    = [string]$x.Message
              File       = $rel
              Line       = [int]$x.Line
              Column     = [int]$x.Column
              EndLine    = [int]$x.EndLine
              EndColumn  = [int]$x.EndColumn
              ScriptName = [string]$x.ScriptName
            })
          }

          # Optional GUI-only suppression (filter out certain rules for GUI scripts)
          $guiRx = [regex]::new($env:GUI_PATH_REGEX)
          $guiSuppress = @($env:GUI_SUPPRESS_RULES -split '\s+' | Where-Object { $_ })
          if ($guiSuppress.Count -gt 0) {
            $rows = @(
              foreach ($r in $rows) {
                $isGui = $guiRx.IsMatch($r.File)
                if ($isGui -and ($r.RuleName -in $guiSuppress)) { continue }
                $r
              }
            )
          }

          # Always write JSON/CSV even if empty
          $rows | ConvertTo-Json -Depth 8 | Set-Content -Path $jsonPath -Encoding UTF8
          $rows | Export-Csv -Path $csvPath -NoTypeInformation -Encoding UTF8

          # SARIF (GitHub-friendly: no runAutomationDetails; use upload-sarif category instead)
          $sarifResults = New-Object System.Collections.Generic.List[object]
          foreach ($r in $rows) {
            $sarifLevel = switch ($r.Severity.ToLowerInvariant()) {
              'error'   { 'error' }
              'warning' { 'warning' }
              default   { 'note' }
            }

            $sarifResults.Add(@{
              ruleId  = $r.RuleName
              level   = $sarifLevel
              message = @{ text = $r.Message }
              locations = @(
                @{
                  physicalLocation = @{
                    artifactLocation = @{ uri = $r.File }
                    region = @{
                      startLine   = [int]$r.Line
                      startColumn = [int]$r.Column
                    }
                  }
                }
              )
            })
          }

          $sarif = @{
            '$schema' = 'http://json.schemastore.org/sarif-2.1.0'
            version   = '2.1.0'
            runs      = @(
              @{
                tool    = @{ driver = @{ name = 'PSScriptAnalyzer'; version = $psaVersion } }
                results = $sarifResults
              }
            )
          }
          $sarif | ConvertTo-Json -Depth 12 | Set-Content -Path $sarifPath -Encoding UTF8

          # Markdown report
          $total  = @($rows).Count
          $bySev  = $rows | Group-Object Severity | Sort-Object Name
          $byRule = $rows | Group-Object RuleName | Sort-Object Count -Descending

          $topN = [int]$env:SUMMARY_TOP
          $topRules = [int]$env:TOP_RULES

          $md = New-Object System.Collections.Generic.List[string]
          $md.Add("# PowerShell Static Analysis Report")
          $md.Add("")
          $md.Add("- **Repo:** $repo")
          $md.Add("- **Commit:** $sha")
          $md.Add("- **Timestamp (UTC):** $ts")
          $md.Add("- **Run:** $runId")
          $md.Add("- **Analyzer:** PSScriptAnalyzer $psaVersion")
          $md.Add("")
          $md.Add("## Summary")
          $md.Add("- **Total findings:** $total")
          foreach ($g in $bySev) { $md.Add("- **$($g.Name):** $($g.Count)") }
          $md.Add("")
          $md.Add("## Top Rules (by count)")
          $md.Add("")
          $md.Add("| Rule | Count |")
          $md.Add("|---|---:|")
          foreach ($r in ($byRule | Select-Object -First $topRules)) {
            $md.Add("| `$($r.Name)` | $($r.Count) |")
          }
          $md.Add("")
          $md.Add("## First $topN Findings")
          $md.Add("")
          $md.Add("| Severity | Rule | File | Line | Message |")
          $md.Add("|---|---|---|---:|---|")
          foreach ($i in ($rows | Select-Object -First $topN)) {
            $fileLink = "https://github.com/$repo/blob/$sha/$($i.File)#L$($i.Line)"
            $msg = ($i.Message -replace '\|','/')
            $md.Add("| $($i.Severity) | `$($i.RuleName)` | [$($i.File)]($fileLink) | $($i.Line) | $msg |")
          }
          [string]::Join([Environment]::NewLine, $md) | Set-Content -Path $mdPath -Encoding UTF8

          # Job summary
          $summary = New-Object System.Collections.Generic.List[string]
          $summary.Add("### üß™ PowerShell Lint Summary")
          $summary.Add("- üïí **UTC:** $ts")
          $summary.Add("- üîó **Repo:** $repo")
          $summary.Add("- üß∑ **Commit:** $sha")
          $summary.Add("- üßæ **Total findings:** $total")
          foreach ($g in $bySev) { $summary.Add("  - **$($g.Name):** $($g.Count)") }
          $summary.Add("")
          $summary.Add("Artifacts are in `lint-reports`: JSON / CSV / MD / SARIF")
          [string]::Join([Environment]::NewLine, $summary) | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8

          # Gate: fail if any configured severities exist
          $failSev = @($env:FAIL_ON_SEVERITIES -split '\s+' | Where-Object { $_ })
          if ($failSev.Count -gt 0) {
            $failHits = @($rows | Where-Object { $_.Severity -in $failSev })
            if ($failHits.Count -gt 0) {
              throw "Lint gate failed: found $($failHits.Count) finding(s) with severity: $($failSev -join ', ')"
            }
          }

      - name: üì¶ Upload Report Artifacts (Structured)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: powershell-lint-reports
          path: ${{ github.workspace }}\${{ env.OUT_DIR }}
          retention-days: 30

      - name: üõ∞Ô∏è Upload SARIF to GitHub Code Scanning
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: ${{ github.workspace }}\${{ env.OUT_DIR }}\${{ env.OUT_SARIF }}
          category: ${{ env.SARIF_CATEGORY }}
          wait-for-processing: true
