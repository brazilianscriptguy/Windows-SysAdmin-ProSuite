name: PowerShell Corporate Lint (PSScriptAnalyzer + SARIF + Reports) [Report-Only]

on:
  push:
    branches: [main, develop]
    paths:
      - "**/*.ps1"
      - "**/*.psm1"
      - "**/*.psd1"
      - ".psscriptanalyzer.psd1"
      - ".github/workflows/psscriptanalyzer-sarif-reports.yml"
  pull_request:
    branches: [main, develop]
    paths:
      - "**/*.ps1"
      - "**/*.psm1"
      - "**/*.psd1"
      - ".psscriptanalyzer.psd1"
      - ".github/workflows/psscriptanalyzer-sarif-reports.yml"
  workflow_dispatch:

concurrency:
  group: powershell-lint-${{ github.ref }}
  cancel-in-progress: true

# Report-only: do NOT block merges based on lint findings
permissions:
  contents: read
  security-events: write

jobs:
  psa-analyze:
    name: üß™ PSScriptAnalyzer (Report-Only) + SARIF + Artifacts
    runs-on: windows-latest
    timeout-minutes: 35

    env:
      PSA_VERSION: "1.24.0"
      SETTINGS_FILE: ".psscriptanalyzer.psd1"

      OUT_DIR: "lint-reports"
      OUT_JSON: "psa-results.json"
      OUT_CSV: "psa-results.csv"
      OUT_MD: "psa-results.md"
      OUT_SARIF: "psa-results.sarif"
      OUT_FAILTXT: "psa-invocation-failed.txt"
      OUT_SUMMARY: "psa-summary.txt"

      # Roots to scan (recursive)
      ANALYZE_ROOTS: >-
        BlueTeam-Tools
        Core-ScriptLibrary
        ITSM-Templates-SVR
        ITSM-Templates-WKS
        ProSuite-Hub
        SysAdmin-Tools

      # Excluded subtree (long paths / GPO export content)
      EXCLUDE_SUBTREE: "SysAdmin-Tools/GroupPolicyObjects-Templates"

      # Directory prune (general)
      PRUNE_DIR_REGEX: '(?i)[\\/](\.git|node_modules|dist|build|artifacts|\.next)[\\/]'

      # SARIF category (keeps runs distinct in Code Scanning)
      SARIF_CATEGORY: "powershell/psscriptanalyzer"

    steps:
      - name: üì¶ Checkout (sparse, exclude long-path subtree)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          sparse-checkout-cone-mode: false
          sparse-checkout: |
            BlueTeam-Tools
            Core-ScriptLibrary
            ITSM-Templates-SVR
            ITSM-Templates-WKS
            ProSuite-Hub
            SysAdmin-Tools
            .psscriptanalyzer.psd1
            !SysAdmin-Tools/GroupPolicyObjects-Templates

      - name: üîß Git long paths (safety)
        shell: pwsh
        run: |
          git config --global core.longpaths true

      - name: üóÇÔ∏è Prepare output folder
        shell: pwsh
        run: |
          $outDir = Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

      - name: üß± Cache PowerShell modules
        uses: actions/cache@v4
        with:
          path: |
            ~\Documents\PowerShell\Modules
            ~\Documents\WindowsPowerShell\Modules
          key: psa-${{ runner.os }}-${{ env.PSA_VERSION }}

      - name: üì• Install PSScriptAnalyzer
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $v = $env:PSA_VERSION

          $have = Get-Module -ListAvailable PSScriptAnalyzer |
            Sort-Object Version -Descending |
            Select-Object -First 1

          if (-not $have -or $have.Version.ToString() -ne $v) {
            Install-Module PSScriptAnalyzer -RequiredVersion $v -Force -Scope CurrentUser -AllowClobber
          }

          Import-Module PSScriptAnalyzer -RequiredVersion $v -Force
          Write-Host "PSScriptAnalyzer version loaded: $((Get-Module PSScriptAnalyzer).Version)"

      - name: üîé Discover PowerShell files (respect excludes)
        id: discover
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $root  = $env:GITHUB_WORKSPACE
          $prune = [regex]::new($env:PRUNE_DIR_REGEX)

          $excludeSub = ($env:EXCLUDE_SUBTREE -replace '/', [IO.Path]::DirectorySeparatorChar)
          $excludeSubEsc = [regex]::Escape($excludeSub)

          $roots = @()
          foreach ($token in ($env:ANALYZE_ROOTS -split '\s+')) {
            if ([string]::IsNullOrWhiteSpace($token)) { continue }
            $p = Join-Path $root $token
            if (Test-Path $p) { $roots += $p }
          }

          $files = @()
          if ($roots.Count -gt 0) {
            $files = foreach ($r in $roots) {
              Get-ChildItem -Path $r -Recurse -File -Include *.ps1,*.psm1,*.psd1 -ErrorAction SilentlyContinue |
                Where-Object {
                  ($_.FullName -notmatch $prune) -and
                  ($_.FullName -notmatch $excludeSubEsc)
                }
            }
          }

          $files = @($files | Sort-Object FullName -Unique)
          $count = @($files).Count

          "count=$count" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          Write-Host "Found $count PowerShell file(s) to analyze."

      - name: üîé Run PSScriptAnalyzer + Build Reports (REPORT-ONLY)
        # This step MUST NOT fail the job. We always produce artifacts.
        if: always()
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Continue'

          $outDir  = Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR
          $jsonOut = Join-Path $outDir $env:OUT_JSON
          $csvOut  = Join-Path $outDir $env:OUT_CSV
          $mdOut   = Join-Path $outDir $env:OUT_MD
          $sarifOut= Join-Path $outDir $env:OUT_SARIF
          $failOut = Join-Path $outDir $env:OUT_FAILTXT
          $sumOut  = Join-Path $outDir $env:OUT_SUMMARY

          # Collect target files again (avoid relying on previous step output content)
          $root  = $env:GITHUB_WORKSPACE
          $prune = [regex]::new($env:PRUNE_DIR_REGEX)
          $excludeSub = ($env:EXCLUDE_SUBTREE -replace '/', [IO.Path]::DirectorySeparatorChar)
          $excludeSubEsc = [regex]::Escape($excludeSub)

          $roots = @()
          foreach ($token in ($env:ANALYZE_ROOTS -split '\s+')) {
            if ([string]::IsNullOrWhiteSpace($token)) { continue }
            $p = Join-Path $root $token
            if (Test-Path $p) { $roots += $p }
          }

          $files = @()
          if ($roots.Count -gt 0) {
            $files = foreach ($r in $roots) {
              Get-ChildItem -Path $r -Recurse -File -Include *.ps1,*.psm1,*.psd1 -ErrorAction SilentlyContinue |
                Where-Object {
                  ($_.FullName -notmatch $prune) -and
                  ($_.FullName -notmatch $excludeSubEsc)
                }
            }
          }

          $files = @($files | Sort-Object FullName -Unique)
          $count = @($files).Count

          # Settings are optional in report-only mode
          $settingsPath = Join-Path $env:GITHUB_WORKSPACE $env:SETTINGS_FILE
          $useSettings = (Test-Path $settingsPath)

          $settingsArgs = @{}
          if ($useSettings) {
            $settingsArgs['Settings'] = $settingsPath
          }

          $results = @()
          try {
            if ($count -gt 0) {
              $results = Invoke-ScriptAnalyzer -Path $files.FullName -Recurse:$false @settingsArgs
            } else {
              "No PowerShell files found to analyze." | Set-Content -Encoding UTF8 $sumOut
            }
          }
          catch {
            # DO NOT fail the workflow: write the exception to a report file
            $_ | Out-String | Set-Content -Encoding UTF8 $failOut
          }

          # Always export at least empty results
          if (-not $results) { $results = @() }

          # JSON
          $results | ConvertTo-Json -Depth 8 | Set-Content -Encoding UTF8 $jsonOut

          # CSV
          $results |
            Select-Object RuleName, Severity, Message, ScriptName, Line, Column |
            Export-Csv -Path $csvOut -NoTypeInformation -Encoding UTF8

          # Markdown summary
          $bySev = $results | Group-Object Severity | Sort-Object Name
          $byRule = $results | Group-Object RuleName | Sort-Object Count -Descending

          $md = New-Object System.Collections.Generic.List[string]
          $md.Add("# PSScriptAnalyzer Report (Report-Only)")
          $md.Add("")
          $md.Add("**Files scanned:** $count")
          $md.Add("**Settings file used:** $useSettings (`$($env:SETTINGS_FILE)`)") 
          $md.Add("")
          $md.Add("## Findings by Severity")
          if ($bySev.Count -eq 0) {
            $md.Add("- None")
          } else {
            foreach ($g in $bySev) { $md.Add("- **$($g.Name)**: $($g.Count)") }
          }
          $md.Add("")
          $md.Add("## Top Rules")
          $top = $byRule | Select-Object -First 20
          if ($top.Count -eq 0) {
            $md.Add("- None")
          } else {
            foreach ($g in $top) { $md.Add("- **$($g.Name)**: $($g.Count)") }
          }
          $md.Add("")
          $md.Add("> Note: This workflow is **report-only**. Findings do **not** fail the job. Reports and SARIF are always produced and uploaded.")
          $md | Set-Content -Encoding UTF8 $mdOut

          # Plain text summary (useful for quick artifact preview)
          $summary = New-Object System.Collections.Generic.List[string]
          $summary.Add("PSScriptAnalyzer (Report-Only)")
          $summary.Add("Files scanned: $count")
          $summary.Add("Settings file used: $useSettings ($($env:SETTINGS_FILE))")
          $summary.Add("Total findings: $(@($results).Count)")
          foreach ($g in $bySev) { $summary.Add("  $($g.Name): $($g.Count)") }
          $summary | Set-Content -Encoding UTF8 $sumOut

          # SARIF: Always produce a SARIF file, even if empty or invocation failed.
          try {
            if ($results.Count -gt 0) {
              # Build a minimal SARIF from the results (tool: PSScriptAnalyzer)
              $sarif = @{
                version = "2.1.0"
                `$schema = "https://json.schemastore.org/sarif-2.1.0.json"
                runs = @(
                  @{
                    tool = @{
                      driver = @{
                        name = "PSScriptAnalyzer"
                        informationUri = "https://github.com/PowerShell/PSScriptAnalyzer"
                        rules = @()
                      }
                    }
                    results = @()
                  }
                )
              }

              # Map severities to SARIF levels
              function Get-SarifLevel([string]$sev) {
                switch -Regex ($sev) {
                  'Error' { 'error' }
                  'Warning' { 'warning' }
                  default { 'note' }
                }
              }

              foreach ($r in $results) {
                $script = [string]$r.ScriptName
                $line   = [int]$r.Line
                $col    = [int]$r.Column
                $ruleId = [string]$r.RuleName

                $sarif.runs[0].results += @{
                  ruleId = $ruleId
                  level  = (Get-SarifLevel ([string]$r.Severity))
                  message = @{ text = [string]$r.Message }
                  locations = @(
                    @{
                      physicalLocation = @{
                        artifactLocation = @{ uri = $script }
                        region = @{
                          startLine = $line
                          startColumn = $col
                        }
                      }
                    }
                  )
                }
              }

              $sarif | ConvertTo-Json -Depth 12 | Set-Content -Encoding UTF8 $sarifOut
            }
            else {
              # Empty SARIF baseline
              $empty = @{
                version = "2.1.0"
                `$schema = "https://json.schemastore.org/sarif-2.1.0.json"
                runs = @(
                  @{
                    tool = @{
                      driver = @{
                        name = "PSScriptAnalyzer"
                        informationUri = "https://github.com/PowerShell/PSScriptAnalyzer"
                      }
                    }
                    results = @()
                  }
                )
              }
              $empty | ConvertTo-Json -Depth 8 | Set-Content -Encoding UTF8 $sarifOut
            }
          }
          catch {
            # Last-resort: still write a valid empty SARIF
            $fallback = @{
              version = "2.1.0"
              `$schema = "https://json.schemastore.org/sarif-2.1.0.json"
              runs = @(@{ tool = @{ driver = @{ name = "PSScriptAnalyzer" } }; results = @() })
            }
            $fallback | ConvertTo-Json -Depth 6 | Set-Content -Encoding UTF8 $sarifOut
            $_ | Out-String | Add-Content -Encoding UTF8 $failOut
          }

          # IMPORTANT: report-only => always exit success
          exit 0

      - name: üì§ Upload lint artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: powershell-lint-reports
          path: ${{ env.OUT_DIR }}/**

      - name: üõ°Ô∏è Upload SARIF to GitHub Code Scanning (Report-Only)
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: ${{ env.OUT_DIR }}/${{ env.OUT_SARIF }}
          category: ${{ env.SARIF_CATEGORY }}
