<#
.SYNOPSIS
    Generates an enterprise-grade PowerShell script scaffold (header, logging, console-hide, GUI/CLI skeleton).

.DESCRIPTION
    Create-Script-MainCodeStructure-Body.ps1 builds a standardized “main body” template aligned to the
    Windows-SysAdmin-ProSuite conventions:
      - StrictMode + predictable error behavior
      - Optional console hiding for GUI-first tools
      - Single log file per run under C:\Logs-TEMP
      - MessageBox helpers for operator feedback
      - GUI/CLI execution model (Windows Forms on Win32NT; CLI fallback otherwise)
      - Clean, fixed WinForms layout with non-truncated buttons
    The output is written to <OutputName>.ps1 in the selected working path.

.FEATURES
    - Generates a ready-to-run PowerShell script scaffold (not just a snippet).
    - Includes ProSuite-standard logging (Initialize-Log / Write-Log / Finalize-Log).
    - Optional console visibility control (-ShowConsole).
    - GUI configuration panel for operators (folder picker + output naming).
    - CLI mode for automation runners and non-Windows execution contexts.
    - Creates the output file with UTF-8 encoding and safe overwrite warnings.

.PARAMETERS
    -Path <String>
        Working directory where the scaffold will be created. Default: script root.

    -OutputName <String>
        Base name for the generated script file. Default: "output"
        Example output: <Path>\<OutputName>.ps1

    -LogDir <String>
        Directory used for logs generated by this generator tool. Default: C:\Logs-TEMP

    -ShowConsole <Switch>
        If set, keeps console visible. Default hides console for GUI-first use.

.NOTES
    - Requires Windows PowerShell 5.1+ for full WinForms GUI experience.
    - Compatible with PowerShell 7+ (GUI still requires Win32NT + WinForms availability).
    - Output scaffold includes placeholders marked as CUSTOM_TASK blocks.

.AUTHOR
    Luiz Hamilton Silva - @brazilianscriptguy

.VERSION
    2.0 - 2026-02-02

.EXAMPLES
    Example 1: GUI execution
    ```powershell
    .\Create-Script-MainCodeStructure-Body.ps1
    ```

    Example 2: CLI execution
    ```powershell
    .\Create-Script-MainCodeStructure-Body.ps1 -Path "C:\Temp" -OutputName "New-Tool" -ShowConsole
    ```
#>

[CmdletBinding()]
param (
    [Parameter(Mandatory = $false)]
    [ValidateScript({ Test-Path $_ -PathType Container })]
    [string]${Path} = $PSScriptRoot,

    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [string]${OutputName} = "output",

    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [string]${LogDir} = 'C:\Logs-TEMP',

    [Parameter(Mandatory = $false)]
    [switch]${ShowConsole}
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

# ---------------------------- GLOBAL CONTEXT ----------------------------
${script:ScriptName} = [System.IO.Path]::GetFileNameWithoutExtension($MyInvocation.MyCommand.Name)
${script:Timestamp}  = (Get-Date -Format "yyyyMMdd_HHmmss")
${script:LogPath}    = $null
${script:LogBuffer}  = New-Object System.Collections.Generic.List[string]

# ---------------------------- CONSOLE HIDE (OPTIONAL) ----------------------------
function Set-ConsoleVisibility {
    param([Parameter(Mandatory=$true)][bool]${Visible})

    if ($PSVersionTable.Platform -ne "Win32NT") { return }

    try {
        Add-Type @"
using System;
using System.Runtime.InteropServices;
public class WinConsole {
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr GetConsoleWindow();
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
    public static void SetVisible(bool visible) {
        var handle = GetConsoleWindow();
        if (handle == IntPtr.Zero) return;
        ShowWindow(handle, visible ? 5 : 0);
    }
}
"@ -ErrorAction Stop

        [WinConsole]::SetVisible(${Visible})
    } catch {}
}

# ---------------------------- LOGGING (PROSUITE) ----------------------------
function Initialize-Log {
    param(
        [Parameter(Mandatory=$false)][string]${Directory} = 'C:\Logs-TEMP'
    )

    if (-not (Test-Path -LiteralPath ${Directory})) {
        New-Item -Path ${Directory} -ItemType Directory -Force | Out-Null
    }

    ${script:LogPath} = Join-Path ${Directory} "${script:ScriptName}.log"

    Write-Log -Message "==== Session started ====" -Level 'INFO'
    Write-Log -Message "Script: ${script:ScriptName}" -Level 'INFO'
    Write-Log -Message "LogPath: ${script:LogPath}" -Level 'INFO'
}

function Write-Log {
    param(
        [Parameter(Mandatory=$true)][string]${Message},
        [Parameter(Mandatory=$false)]
        [ValidateSet('INFO','WARN','ERROR','SUCCESS','DEBUG')]
        [string]${Level} = 'INFO'
    )

    if ([string]::IsNullOrWhiteSpace(${script:LogPath})) {
        ${fallbackDir} = 'C:\Logs-TEMP'
        if (-not (Test-Path -LiteralPath ${fallbackDir})) {
            New-Item -Path ${fallbackDir} -ItemType Directory -Force | Out-Null
        }
        ${script:LogPath} = Join-Path ${fallbackDir} "${script:ScriptName}.log"
    }

    ${ts} = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    ${entry} = "[${ts}] [${Level}] ${Message}"

    try { Add-Content -Path ${script:LogPath} -Value ${entry} -Encoding UTF8 -ErrorAction Stop } catch {}
    ${script:LogBuffer}.Add(${entry}) | Out-Null

    if ($VerbosePreference -eq 'Continue') { try { Write-Verbose ${entry} } catch {} }
}

function Finalize-Log {
    Write-Log -Message "==== Session ended ====" -Level 'INFO'
}

function Handle-Error {
    param(
        [Parameter(Mandatory=$true)][string]${ErrorMessage},
        [Parameter(Mandatory=$false)][switch]${ShowMessageBox}
    )

    Write-Log -Message ${ErrorMessage} -Level 'ERROR'

    if (${ShowMessageBox} -and $PSVersionTable.Platform -eq "Win32NT") {
        try {
            Add-Type -AssemblyName System.Windows.Forms -ErrorAction Stop
            [void][System.Windows.Forms.MessageBox]::Show(${ErrorMessage}, "Error", "OK", "Error")
        } catch {}
    }
}

# ---------------------------- SCAFFOLD GENERATION ----------------------------
function New-ScriptScaffoldContent {
    param(
        [Parameter(Mandatory=$true)][string]${NewScriptName}
    )

@"
<#
.SYNOPSIS
    <One-line purpose (imperative + outcome).>

.DESCRIPTION
    <Describe what this script does and the operational context.>
    This script follows Windows-SysAdmin-ProSuite standards:
    - StrictMode enabled and predictable error behavior
    - Logging to C:\Logs-TEMP
    - GUI-friendly (MessageBox feedback) and optional console hiding

.FEATURES
    - Structured logging (Initialize-Log / Write-Log / Finalize-Log).
    - Optional console hiding for GUI-first workflows.
    - Clear operator feedback (Info/Warn/Error).
    - Optional CSV export to Documents folder (as needed).

.PARAMETERS
    -ShowConsole <Switch>
        Keeps the console visible (debugging). Default hides console.

.AUTHOR
    Luiz Hamilton Silva - @brazilianscriptguy

.VERSION
    1.0 - $(Get-Date -Format "yyyy-MM-dd")
#>

#Requires -RunAsAdministrator
[CmdletBinding()]
param(
    [switch]`$ShowConsole
)

Set-StrictMode -Version Latest
`$ErrorActionPreference = 'Stop'

# ---------------------------- Hide Console (Optional) ----------------------------
function Set-ConsoleVisibility {
    param([Parameter(Mandatory=`$true)][bool]`$Visible)
    if (`$PSVersionTable.Platform -ne "Win32NT") { return }
    try {
        Add-Type @"
using System;
using System.Runtime.InteropServices;
public class WinConsole {
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr GetConsoleWindow();
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
    public static void SetVisible(bool visible) {
        var handle = GetConsoleWindow();
        if (handle == IntPtr.Zero) return;
        ShowWindow(handle, visible ? 5 : 0);
    }
}
"@ -ErrorAction Stop
        [WinConsole]::SetVisible(`$Visible)
    } catch {}
}

if (-not `$ShowConsole) { Set-ConsoleVisibility -Visible `$false }

# ---------------------------- Logging ----------------------------
`$scriptName = [System.IO.Path]::GetFileNameWithoutExtension(`$MyInvocation.MyCommand.Name)
`$logDir     = 'C:\Logs-TEMP'
if (-not (Test-Path -LiteralPath `$logDir)) { New-Item -Path `$logDir -ItemType Directory -Force | Out-Null }
`$logPath    = Join-Path `$logDir "`$scriptName.log"

function Write-Log {
    param(
        [Parameter(Mandatory=`$true)][string]`$Message,
        [ValidateSet('INFO','WARN','ERROR','SUCCESS','DEBUG')][string]`$Level = 'INFO'
    )
    `$ts = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    `$entry = "[`$ts] [`$Level] `$Message"
    Add-Content -Path `$logPath -Value `$entry -Encoding UTF8 -ErrorAction SilentlyContinue
}

Write-Log -Message "==== Session started ====" -Level 'INFO'

# ---------------------------- CUSTOM_TASK ----------------------------
try {
    Write-Log -Message "TODO: implement main logic for ${NewScriptName}" -Level 'INFO'
    # Place your enterprise logic here
    Write-Log -Message "Task completed." -Level 'SUCCESS'
} catch {
    Write-Log -Message "Unhandled error: `$(`$_.Exception.Message)" -Level 'ERROR'
    throw
} finally {
    Write-Log -Message "==== Session ended ====" -Level 'INFO'
}
"@
}

function Write-ScaffoldToDisk {
    param(
        [Parameter(Mandatory=$true)][string]${WorkPath},
        [Parameter(Mandatory=$true)][string]${OutName}
    )

    ${safeName} = ${OutName}.Trim()
    if ([string]::IsNullOrWhiteSpace(${safeName})) {
        throw "OutputName cannot be empty."
    }

    ${targetPath} = Join-Path ${WorkPath} "${safeName}.ps1"
    ${content} = New-ScriptScaffoldContent -NewScriptName ${safeName}

    if (Test-Path -LiteralPath ${targetPath}) {
        Write-Log -Message "Output file already exists and will be overwritten: ${targetPath}" -Level 'WARN'
    }

    ${content} | Out-File -FilePath ${targetPath} -Force -Encoding UTF8
    Write-Log -Message "Scaffold created: ${targetPath}" -Level 'SUCCESS'
    return ${targetPath}
}

# ---------------------------- GUI ----------------------------
function Show-GUI {
    Add-Type -AssemblyName System.Windows.Forms
    Add-Type -AssemblyName System.Drawing
    [System.Windows.Forms.Application]::EnableVisualStyles()

    ${uiLeft} = 10
    ${uiTop}  = 12
    ${uiGap}  = 10
    ${uiLblW} = 110
    ${uiBoxW} = 420
    ${uiBtnH} = 30

    ${form} = New-Object System.Windows.Forms.Form
    ${form}.Text = "${script:ScriptName}"
    ${form}.Size = New-Object System.Drawing.Size(640, 260)
    ${form}.StartPosition = "CenterScreen"
    ${form}.MaximizeBox = $false
    ${form}.FormBorderStyle = 'FixedDialog'

    # Working Path
    ${lblPath} = New-Object System.Windows.Forms.Label
    ${lblPath}.Text = "Working Path:"
    ${lblPath}.Location = New-Object System.Drawing.Point(${uiLeft}, ${uiTop})
    ${lblPath}.Size = New-Object System.Drawing.Size(${uiLblW}, 20)
    ${form}.Controls.Add(${lblPath})

    ${txtPath} = New-Object System.Windows.Forms.TextBox
    ${txtPath}.Location = New-Object System.Drawing.Point((${uiLeft} + ${uiLblW}), (${uiTop} - 2))
    ${txtPath}.Size = New-Object System.Drawing.Size(${uiBoxW}, 20)
    ${txtPath}.Text = ${Path}
    ${form}.Controls.Add(${txtPath})

    ${btnBrowse} = New-Object System.Windows.Forms.Button
    ${btnBrowse}.Text = "Browse"
    ${btnBrowse}.Size = New-Object System.Drawing.Size(80, 23)
    ${btnBrowse}.Location = New-Object System.Drawing.Point((${txtPath}.Right + ${uiGap}), (${uiTop} - 4))
    ${btnBrowse}.Add_Click({
        ${dlg} = New-Object System.Windows.Forms.FolderBrowserDialog
        if (${dlg}.ShowDialog() -eq "OK") { ${txtPath}.Text = ${dlg}.SelectedPath }
    })
    ${form}.Controls.Add(${btnBrowse})

    # Output Name
    ${lblOut} = New-Object System.Windows.Forms.Label
    ${lblOut}.Text = "Output Name:"
    ${lblOut}.Location = New-Object System.Drawing.Point(${uiLeft}, (${uiTop} + 32))
    ${lblOut}.Size = New-Object System.Drawing.Size(${uiLblW}, 20)
    ${form}.Controls.Add(${lblOut})

    ${txtOut} = New-Object System.Windows.Forms.TextBox
    ${txtOut}.Location = New-Object System.Drawing.Point((${uiLeft} + ${uiLblW}), (${uiTop} + 30))
    ${txtOut}.Size = New-Object System.Drawing.Size(${uiBoxW}, 20)
    ${txtOut}.Text = ${OutputName}
    ${form}.Controls.Add(${txtOut})

    # Log Dir
    ${lblLog} = New-Object System.Windows.Forms.Label
    ${lblLog}.Text = "Log Dir:"
    ${lblLog}.Location = New-Object System.Drawing.Point(${uiLeft}, (${uiTop} + 64))
    ${lblLog}.Size = New-Object System.Drawing.Size(${uiLblW}, 20)
    ${form}.Controls.Add(${lblLog})

    ${txtLog} = New-Object System.Windows.Forms.TextBox
    ${txtLog}.Location = New-Object System.Drawing.Point((${uiLeft} + ${uiLblW}), (${uiTop} + 62))
    ${txtLog}.Size = New-Object System.Drawing.Size(${uiBoxW}, 20)
    ${txtLog}.Text = ${LogDir}
    ${form}.Controls.Add(${txtLog})

    # Buttons
    ${btnRun} = New-Object System.Windows.Forms.Button
    ${btnRun}.Text = "Generate Scaffold"
    ${btnRun}.Size = New-Object System.Drawing.Size(150, ${uiBtnH})
    ${btnRun}.Location = New-Object System.Drawing.Point((${uiLeft} + ${uiLblW}), (${uiTop} + 100))
    ${form}.Controls.Add(${btnRun})

    ${btnExit} = New-Object System.Windows.Forms.Button
    ${btnExit}.Text = "Exit"
    ${btnExit}.Size = New-Object System.Drawing.Size(100, ${uiBtnH})
    ${btnExit}.Location = New-Object System.Drawing.Point((${btnRun}.Right + ${uiGap}), ${btnRun}.Top)
    ${btnExit}.Add_Click({ ${form}.Close() })
    ${form}.Controls.Add(${btnExit})

    ${lblStatus} = New-Object System.Windows.Forms.Label
    ${lblStatus}.Text = "Ready"
    ${lblStatus}.AutoSize = $false
    ${lblStatus}.Size = New-Object System.Drawing.Size(610, 40)
    ${lblStatus}.Location = New-Object System.Drawing.Point(${uiLeft}, (${btnRun}.Bottom + 10))
    ${form}.Controls.Add(${lblStatus})

    ${btnRun}.Add_Click({
        try {
            ${script:Path}       = ${txtPath}.Text.Trim()
            ${script:OutputName} = ${txtOut}.Text.Trim()
            ${script:LogDir}     = ${txtLog}.Text.Trim()

            if (-not (Test-Path -LiteralPath ${script:Path})) {
                Handle-Error -ErrorMessage "Working Path does not exist: ${script:Path}" -ShowMessageBox
                return
            }

            Initialize-Log -Directory ${script:LogDir}
            Write-Log -Message "Generating scaffold: Path='${script:Path}', OutputName='${script:OutputName}'" -Level 'INFO'

            ${outFile} = Write-ScaffoldToDisk -WorkPath ${script:Path} -OutName ${script:OutputName}
            ${lblStatus}.Text = "Generated: ${outFile}"
            [void][System.Windows.Forms.MessageBox]::Show("Scaffold generated successfully!`n${outFile}", "Success", "OK", "Information")

        } catch {
            Handle-Error -ErrorMessage "Generation failed: $($_.Exception.Message)" -ShowMessageBox
        } finally {
            try { Finalize-Log } catch {}
        }
    })

    [void]${form}.ShowDialog()
}

# ---------------------------- MAIN ----------------------------
try {
    if (-not ${ShowConsole}) { Set-ConsoleVisibility -Visible $false }

    Initialize-Log -Directory ${LogDir}
    Write-Log -Message "Starting ${script:ScriptName}" -Level 'INFO'
    Write-Log -Message "Parameters - Path='${Path}', OutputName='${OutputName}', LogDir='${LogDir}', ShowConsole=${ShowConsole}" -Level 'INFO'

    if ($PSVersionTable.Platform -eq "Win32NT") {
        Show-GUI
    } else {
        Write-Warning "GUI not supported on non-Windows platforms. Running in CLI mode."
        ${file} = Write-ScaffoldToDisk -WorkPath ${Path} -OutName ${OutputName}
        Write-Output ${file}
    }
} catch {
    Handle-Error -ErrorMessage "Fatal error: $($_.Exception.Message)" -ShowMessageBox
} finally {
    try { Finalize-Log } catch {}
}

# End of Script
